/*假如一个类有两个构造参数，一个有参，一个无参。
那么 new 出来的数组可能是无参的，等到下面用的时候要注意。
例:
   Person* parray=new Person[10];
  
   Person * parr=new Person[]("parameter");
   
   */
   
   

/*
编译器将我们自己定义的析构函数当作了普通成员函数处理，实际上不像构造函数，我们自己定义析构函数的时候，不会覆盖系统提供的析构函数；同时用户定义的析构函数，就是我们析构函数体内的内容，而系统提供的析构函数是负责对象的清理的。编译器允许显式调用析构函数，但是这种调用仅仅是调用了我们定义的析构函数（也就是当作普通成员函数处理的那个版本），并没有调用系统的析构函数。在本例中，显式“释放”p1时，实际上只是收回了p1.a所占的堆内存，p1.x，p1.y，p1.func()所占的栈内存并未释放，所以我们仍可以在显式“释放”p1之后调用它的func()方法，在对象生命周期结束（本例为程序结束）时，系统会自动调用对象的两种析构函数，以回收堆内存和栈内存（当然本例中尝试回收堆内存时出现了错误）。
*/





/*
    void *arrP = operator new(sizeof(Person));//不会调用构造函数，只返回内存
	operator delete(arr_p);
	//arr_p会变成野指针 不会为NULL
	new(arrP) Person(10,20);//(placement new )会在arrP指向的内存中调用Person的构造函数构建一个Person对象
	Person p1;
	p1.TDeConsr();
	p1.~Person();
	p1.TDeConsr();
	//手动调用析构函数相当于调用了一个普通函数差不多，只是把类内的属性值都清空了，但是此对象不会被清除。
*/
